import * as THREE from 'three';

// setup the scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( //this kind of camera projects a "3D world" in a 2D screen.
    75, // Field of View
    window.innerWidth / window.innerHeight, // aspect ratio
    0.1, // any object closer than 0.1 units from the camera will not be rendered
    1000 // any object farther than 1000 units from the camera will not be rendered
);
const renderer = new THREE.WebGLRenderer(); // utilize the WebGL API to display scenes

renderer.setSize(window.innerWidth, window.innerHeight); // sets size of the render to fill the window.
document.body.appendChild( renderer.domElement ); // attach renderer to the DOM. this makes it visible in the browser.

// add light
const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // parameters: color and intensity
directionalLight.position.set(0, 1, 5) // x, y, and z position
scene.add(directionalLight);


// verticies = points in 3D space that define each corner of a polygon. 
// generate the cube using vertex and fragment shaders.
const material = new THREE.MeshStandardMaterial({ color: 0xff5733  }); // set the color of the cube and material that covers the geoemtry. creates a fragment shader that assigns a color to every pixel and using physically based rendering.
const geometry = new THREE.BoxGeometry(); // define geometry of the cube. 1 x 1 x 1 by default. this calculates the necessary verticies to draw a cube.
const cube = new THREE.Mesh(geometry, material); // combine the geometry and material to create the mesh. this is effectively compiling a vertex shader in openGL
scene.add(cube);

camera.position.z = 5; // move the camera 5 units away from the origin on the z axis. this is the view transformation.

// rendering loop
function animate() {
    requestAnimationFrame(animate);  // call this animation function recursively. it will be called for each time the screen is refreshed. in most cases, this is sixty times per second.
    // model transformation for each frame:
    cube.rotation.y += 0.01; // rotate the cube by 0.01 radians around y-axis. 
    cube.rotation.x += 0.01; // rotate the cube by 0.01 radians around x-axis

    renderer.render(scene, camera)
}

/*
Animate function does this:
    1. processes the vertex shaders: cube's verticies are passed through the vertex shader, applying transformations based on the model matrix (cube's position, rotation, and scale), view matrix (orientation), camera's position, 
    the projection matrix (camera's projection parameters)
    2. rasterization: the transformed verticies form triangles that are rasterized to determine which pixels they cover.
    3. process fragment shader: for each pixel covered by a triangle, the fragment shader determines the color of that pixel.
    4. rendering: the colors generated by the fragment shader are written to the screen. this creates the visible image of the rotating cube.
    entire process is run on the GPU.
*/
animate();


